# 03장 HTTP 메시지

- [HTTP 메시지란?](#http-메시지란)
- [HTTP 메시지 흐름](#http-메시지-흐름)
  - [트랜잭션 방향](#트랜잭션-방향)
  - [메시지 흐름](#메시지-흐름)
- [메시지의 각 부분](#메시지의-각-부분)
- [메시지 문법](#메시지-문법)
  - [시작줄](#시작줄)
    - [요청줄](#요청줄)
    - [응답줄](#응답줄)
  - [헤더](#헤더)
    - [일반 헤더](#일반-헤더)
    - [요청 헤더](#요청-헤더)
    - [응답 헤더](#응답-헤더)
    - [엔터티 헤더](#엔터티-헤더)
    - [확장 헤더](#확장-헤더)
  - [본문(엔터티 본문)](#본문엔터티-본문)

# HTTP 메시지란?

HTTP 메시지는 HTTP 클라이언트와 서버 간에 일을 처리(혹은 트랜잭션을 구현)하기 위해서 주고받은 데이터의 블록, 또는 클라이언트와 서버 간에 데이터가 교환되는 방식이에요.

# HTTP 메시지 흐름

HTTP 메시지는 클라이언트, 서버, 프락시 사이를 흘러요.

메세지 흐름의 방향으로는 인바운드, 아웃바운드, 업스트림, 다운스트림이 있고, 메세지는 항상 인바운드에서 아웃바운드로 이동해요.

## 트랜잭션 방향

- **인바운드**: 원 서버(origin server)로 이동하는 것
- **아웃바운드**: 사용자 에이전트로 이동하는 것

즉, 메시지가 서버로 이동할 때는 인바운드로 이동, 서버에서 처리가 끝난 뒤에 클라이언트 복귀할 때는 아웃바운드로 이동해요.

## 메시지 흐름

- **업스트림**: 위로 흐름
- **다운 스트림**: 아래로 흐름

HTTP 메시지는 클라이언트 방향 혹은 서버 방향으로 이동하는 것과 상관 없이 다운스트림으로 흘러요. 업스트림과 다운 스트림은 발송자와 수신자를 기준으로 하며, 발송자는 수신자의 업스트림이 돼요.

# 메시지의 각 부분

메시지는 시작줄(Start line), 헤더(HTTP `HEAD`ers), 본문(Body)으로 이뤄져있어요.

시작줄과 헤더는 ASCII 문자열이고 CRLF라는 줄바꿈(New Line) 문자열로 끝나는데 위 이미지에서는 빈 줄(Empty line)이 여기에 해당돼요.

시작줄이나 헤더와는 달리, 본문은 텍스트나 이진 데이터(ex. 음악, 동영상, 이미지 등등)를 포함할 수도 있고 그냥 비어있을 수도 있어요.

# 메시지 문법

모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류돼요.

- **요청 메시지**: 클라이언트가 서버로 전달해서 서버의 액션이 일어나게끔 하는 메시지
- **응답 메시지**: 요청에 대한 서버의 답변

아래 이미지는 요청 메시지와 응답 메시지의 구조를 나타내고 있습니다. 각 메시지는 동일하게 시작줄, 헤더, 본문를 가지고 있어요.

그리고 헤더 목록의 끝에 빈 줄 즉, CRLF로 헤더 목록의 끝과 본문의 시작을 표시해요.

## 시작줄

### 요청줄

서버에서 어떤 동작이 일어나야 하는지 설명해주는 역할을 헤요.

시작줄은 **메서드, URL, HTTP 버전**으로 구성되어 있어요.

### 메서드

서버에게 무엇을 해야하는지 말해주는 역할을 해요 (모든 서버가 모든 메서드를 구현하지는 않아요).

메서드는 대부분 제한적으로 사용되는데, 이 제한은 일반적으로 서버 설정에 의해 정해지며 사이트마다 또 서버마다 다를 수 있어요. 예를 들면, `DELETE`나 `PUT`을 지원하는 서버는 아무나 리소스를 제거하거나 수정하지 못하도록 제한할 수 있어요.

**메서드 종류**

**`GET`**

- 서버에게 리소스를 요청하는 메서드이며, 데이터를 가져올 때만 사용해요.
- 쿼리 문자열은 `GET` 요청의 URL로 전송해요.

ex. `http://charlie.com/friends?orderByFavorites=true&view=grid`

- `GET` 요청시 브라우저 히스토리에 남아요.
- 중요한 데이터를 처리할 때 `GET` 요청으로 처리하면 안돼요.
- 데이터를 전송할 때 `GET` 메서드는 데이터를 URL에 추가해요.
- 최대 URL 길이는 2048자까지라서 데이터 길이에 제한이 있어요.
- ASCII 데이터 타입만 전송 가능해요.

**`HEAD`**

- `GET` 메서드의 요청과 동일한 응답을 요구하지만, 서버는 응답으로 헤더만 돌려주고 본문(reponse body)은 반환되지 않아요.
- 만약 본문이 존재하더라도 무시해야 해요.
- 클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만을 조사할 수 있게 해줘요.
- 이 때 `HEAD` 요청을 통해 얻는 헤더는 `GET` 요청을 통해 얻는 헤더와 정확히 일치해야 해요.
- `GET` 요청을 실제로 수행하기 전, `HEAD`를 통해 알 수 있는 것들은 아래와 같아요:
  - 헤더를 통해서 리소스 정보 얻기
  - 헤더를 통해서 리소스가 변경되었는지 검사하기
  - 응답의 상태 코드를 통해 개체가 존재하는지 확인

**`POST`**

- 서버로 데이터를 전송하는 메서드예요.
- `POST` 요청은 보통 HTML 폼을 통해 서버에 전송해요.
- `POST` 요청은 반복적으로 호출하면 동일한 리소스를 여러 번 생성하는 부작용이 발생해요.
- `POST` 요청시 브라우저 히스토리에 남지 않아요.
- 데이터 전송 시 데이터 길이에 제한이 없어요.
- 데이터 타입 제한이 없어요.

**`PUT`**

- 데이터를 서버로 전송해서 새로운 리소스를 생성하거나 수정(기존 데이터를 전송받은 데이터로 교체)하는데 사용해요.
- `POST`와 달리 `PUT`은 데이터를 한 번 보내든 여러 번 보내든 같은 결과를 보여주고, 여러 번 보냈다고 하여 데이터 생성이 발생하지 않아요.
  - `PUT`은 멱등성 특징을 갖는 메서드예요.

**`TRACE`**

- 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려주며 이 과정에서 루프백(디지털 데이트 스트림이 의도적인 수정없이 원래의 지점으로 되돌아감) 검사를 해요.
- `TRACE` 사용 예시

  - 요청이 의도한대로 요청/응답 연쇄(chain)를 통과하는지 확인할 수 있어요.
  - 프락시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지 알 수 있어요.

- 요청이 유효하다면, 응답은 전체 요청 메시지를 `Content-type: "message/http"` 헤더와 함께 본문에 포함시켜야 해요.

**`OPTIONS`**

- 지정된 URL 또는 서버에 대해 허용된 통신 옵션을 요청해요.
- 예를 들면 클라이언트는 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있어요.

**`DELETE`**

- 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청해요.
- 그러나 서버에서 반환된 상태 코드가 삭제 작업이 성공적으로 완료되었음을 나타내더라도, 클라이언트는 이 작업이 수행된 것을 보장할 수 없어요.

**`확장 메서드`**

- HTTP/1.1 명세에 정의되지 않은 메서드예요.
- HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으며, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않아요.

아래는 대표적인 확장 메서드예요.

| 메서드   | 설명                                |
| -------- | ----------------------------------- |
| `LOCK`   | 사용자가 리소스를 잠글 수 있게 해줌 |
| `MIKCOL` | 사용자가 문서를 생성할 수 있게 해줌 |
| `COPY`   | 서버에 있는 리소스를 복사           |
| `MOVE`   | 서버에 있는 리소스를 옮김           |

**안전한 메서드**

- HTTP 메서드가 서버의 상태를 바꾸지 않으면, 해당 메서드가 안전하다고 말해요.
- 즉, 읽기 작업만 수행하는 메서드는 안전해요. 그리고 HTTP 요청의 결과로 인해 서버에서 일어나는 일은 아무것도 없어요.
- 메서드 중에서는 `GET`, `HEAD`, `OPTIONS` 그리고 `TRACE`가 해당돼요.
- 브라우저 입장에서는 안전한 메서드라면 서버에 해를 끼치지 않을 것임을 알 수 있기 때문에 자유롭게 호출이 가능해요.
- 그렇지만 안전한 메서드가 서버에 작용을 유발하지 않는다는 보장이 없어요. 그래서 안전하지 않는 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 해요.
  (ex. 신용 카드 결제가 된다는 것을 알려주는 경고 메세지 띄우기)
- 또한 메서드의 안전함을 준수하는 것은 온전히 서버 어플리케이션의 책임으로 Apache나 Nginx와 같은 웹 서버는 스스로 안전함을 강제하지 못해요. 특히 `GET` 요청을 받았을 때 자신의 상태가 바뀌지 않도록 해야 해요.

### 요청 URL

요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소예요.

### HTTP버전

HTTP 애플리케이션들이 자신이 따르는 HTTP의 버전을 상대방에게 말해주기 위한 수단으로, 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리켜요.

형식은 아래와 같으며 분수가 아니라 .을 기준으로 분리된 숫자(정수)로 봐야해요. 예를 들어 1.22가 1.3 보다 버전이 높아요.

```
HTTP/<메이저>.<마이너>
```

- 버전 번호가 필요한 이유
  - HTTP로 대화하는 애플리케이션들에게 대화 상대의 능력과 메시지의 형식에 대한 단서를 제공해주기 위함이에요.
  - 예를 들어 HTTP 1.1과 새로운 기능이 추가된 HTTP 1.2가 서로 대화한다고 할 때, 1.1은 1.2가 가진 기능을 사용할 수 없다는 것을 1.2는 알아야 해요.

### 응답줄

수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려줘요.

시작줄은 **HTTP 버전, 상태 코드, 사유 구절**로 구성되어 있어요.

### HTTP 버전

요청줄에서 HTTP 버전을 작성하는 방법과 동일해요.

### 상태 코드

- 지정한 HTTP 요청이 성공적으로 완료되었는지를 나타내요.
- 숫자로 된 코드는 프로그램이 에러를 처리하기 쉬워요.
- 프로토콜이 진화하면서 더 많은 상태코드가 HTTP 명세에 공식적으로 정의돼요. 그래서 내가 모르는 상태 코드를 받게 되면, 누군가 프로토콜의 확장으로 정의했을 가능성이 있어요.

**`100~199` 정보성 상태 코드**

`100 Continue`

- 클라이언트가 서버로 보낸 요청에 문제가 없으니 다음 요청을 이어서 보내도 된다는 것을 의미해요.
- 만약 클라이언트의 작업(본문 수신)이 완료되었다면 이 응답은 무시해도 돼요.
- 클라이언트가 서버로 하여금 검토하게 하려면 첫 번째 요청에서 `Expect: 100-continue` 헤더를 보내야 해요. 이후 클라이언트는 본문을 보내기 전에 서버가 `100 Continue` 상태 코드로 응답하길 기다려야 해요.
- 하지만, 막연히 기다리지 말고 약간의 타임 아웃 후에는 그냥 엔터티를 보내야 해요.
- 만약 HTTP 1.1 이전의 버전을 사용하는 웹 서버나 애플리케이션을 사용한다면 문제가 될 수 있어요.

**`200~299` 성공 상태 코드**

`200 OK`

- 요청 성공을 의미해요.
- 새롭게 업데이트한 페이지를 보여줘야할 경우에 사용해요.

`201 Created`

- 요청이 성공적으로 처리되었으며, 리소스가 생성되었음을 나타내요.

`202 Accepted`

- 요청이 성공적으로 접수되었으나, 아직 해당 요청에 대해 처리중이거나 처리 시작 전임을 의미해요
- 요청이 처리 중 실패할 수도 있기 때문에 요청은 실행될 수도 실행되지 않을 수도 있어요.

`204 No Content`

- 헤더와 상태줄(시작줄)을 포함하지만 엔터티 본문은 포함하지 않어요.
- `204`를 반환하는 경우는 `PUT` 요청에 대한 응답으로, 사용자에게 보여지는 페이지를 바꾸지 않고 리소스를 업데이트할 때 사용돼요.

**`300~399` 리다이렉션 상태 코드**

리다이렉션을 통해 리소스가 옮겨졌다면, 클라이언트에게 리다이렉션 상태 코드와 (선택적으로) Location 헤더를 보내 바뀐 위치를 알려줄 수 있어요.

가장 적절한 리다이렉트 상태 코드를 선택하기 위해 클라이언트의 HTTP 버전을 검사할 필요가 있어요.

`300 Multiple Choices`

- 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 그 리소스의 목록과 함께 반환하고, 사용자는 목록에서 원하는 하나 선택 가능해요.
- 하나의 HTML 문서에 다국어를 제공하는 경우 사용 가능해요.

`301 Moved Permaently`

- 요청한 리소스가 Location 헤더에 주어진 URL로 완전히 옮겨졌다는 것을 나타내요.
- 리다이렉트를 수행할 때 메소드와 응답 본문이 바뀌어서는 안돼요.
- 그러므로 `301` 코드는 `GET`과 `HEAD` 메소드의 응답으로만 사용해요.

`302 Found`

- `301` 상태 코드과 같으며, 클라이언트가 요청한 리소스가 Location 헤더에 주어진 URL에 일시적으로 이동되었음을 가리켜요.

`303 See Other`

- 클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말해주고자 할 때 쓰여요.

`304 Not Modified`

- 클라이언트는 헤더를 이용해 조건부 요청을 만들 수 있어요.
- 만약 클라이언트가 `GET` 요청을 통해 `If-Modified-Since` 헤더를 전달했고, 요청한 리소스가 최근에 수정된 일이 없다면 이 코드는 리소스가 수정되지 않았다는 것을 의미해요.
- `304` 상태 코드는 리소스가 캐시된 상태예요.

`307 Temporary Redirect`

- `301` 상태코드와 비슷해요.
- 그러나 클라이언트는 Location 헤더에 주어진 URL을 임시로 리소스를 가리키기 위한 목적으로 사용해야 해요.
- 사용자 에이전트가 반드시 사용된 HTTP 메소드를 변경하지 말아야 하는 점만 다름. 만약 첫 요청에 `POST`가 사용되었다면, 두번째 요청도 반드시 `POST`를 사용해야 해요.

(참고: `305 Use Proxy` 상태코드는 deprecated 되었어요.)

**`404~499` 클라이언트 에러 상태 코드**

`400 Bad Request`

- 클라이언트가 잘못된 요청을 보냈다고 말해줘요.
- 잘못된 요청 구문, 유효하지 않은 요청, 또는 변조된 요청 라우팅과 같은 클라이언트 오류를 감지해 요청을 처리할 수 없거나 하지 않는다는 것을 의미해요.

`401 Unauthorized`

- 해당 리소스에 유효한 인증 자격 증명이 없기 때문에 요청이 적용되지 않았음을 나타내요.

`403 Forbidden`

- 요청이 서버에 의해 거부됨을 의미해요.

`404 Not Found`

- 서버가 요청한 URL을 찾을 수 없음을 알려주기 위해 사용해요.
- 아래와 같이 종종 클라이언트 애플리케이션이 사용자에게 보여주기 위한 엔터티가 포함되기도 해요.

`405 Method Not Allowed`

- 요청한 URL에 대해, 지원하지 않는 메서드로 요청받았을 때 사용해요.
- 요청한 리소스에 대해 어떤 메서드가 사용 가능한지 클라이언트에게 알려주기 위해, 요청에 `Allow` 헤더가 포함되어야 해요.
- 유의 사항으로는 두 가지 필수 메소드인 `GET`과 `HEAD`는 사용 불가능 하여서는 안 되며, 이러한 오류 타입을 반환해서는 안돼요.

`409 Conflict`

- 서버의 현재 상태와 요청이 충돌했음을 나타내요.
- 충돌은 `PUT` 요청에 대응하여 발생할 가능성이 가장 높아요. 예를 들어 서버에 이미 있는 파일보다 오래된 파일을 업로드 할 때 발생할 수 있어요.

`414 Request URI Too Long`

- 서버가 처리할 수 있는 혹은 처리하고나 하는 한계를 넘은 길이의 요청 URL이 포함된 요청을 클라이언트가 보냈을 때 사용해요.

**`500~599` 서버 에러 상태 코드**

`500 Internal Server Error`

- 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용해요.

`502 Bad Gateway`

- 서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 수행하려고 시도하는 동안 액세스한 인바운드 서버로부터 잘못된 응답을 받았음을 나타내요.

`503 Service Unavaliable`

- 현재는 서버가 요청을 처리해 줄 수 없지만 나중에는 가능함을 의미하고자 할 때 사용해요.
- 일반적인 원인은 유지보수를 위해 작동이 중단되거나, 과부하가 걸렸을 때 발생해요.
- 보통 티켓팅이나 수강신청 등의 이벤트로 트래픽이 초과 되었을 때 만날 수 있어요.

`504 Gateway Timeout`

- 서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 완료하기 위해 액세스해야 하는 업스트림 서버로부터 제때 응답을 받지 못했음을 나타내요.

### 사유 구절

상태 코드에 대해 사람이 이해하기 쉽도록 글로 된 설명을 제공해요.
예를 들면, `HTTP/1.1 200 OK` 에서 `OK`가 사유 구절이에요.

상태 코드와 일대일로 대응되지만, `HTTP/1.1 200 NOT OK` 라고 되어있어도 상태 코드 `200`은 성공을 처리하기 때문에 사유 구절과 상관없이 상태 코드 값을 기준으로 작업을 수행해야 해요.

## 헤더

클라이언트와 서버가 요청 또는 응답으로 부가적인 정보를 전송할 수 있도록 해줘요.

헤더는 대소문자를 구분하지 않는 이름과 콜론 `:` 다음에 오는 값으로 이루어져 있고, 값 앞에 붙은 빈 문자열은 무시돼요.

HTTP 헤더의 집합은 항상 빈줄(CRLF)로 끝나야 해요.

헤더는 **일반 헤더, 요청 헤더, 응답 헤더, 엔터티 헤더, 확장 헤더** 등으로 분류돼요.

### 일반 헤더

- 요청과 응답 모두에 적용되며, 메시지에 대한 아주 기본적인 정보를 제공해요.
- Body에서 최종적으로 전송되는 데이터와는 관련이 없는 헤더예요.

  |     헤더     |                             설명                             |
  | :----------: | :----------------------------------------------------------: |
  |    `Date`    |             메시지가 만들어진 날짜와 시간을 포함             |
  | `Connection` | 현재의 전송이 완료된 후 네트워크 접속을 유지할지 말지를 제어 |

#### 일반 캐시 헤더

- HTTP/1.0은 HTTP 애플리케이션에게 매번 서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있도록 해주는 최초의 헤더를 도입했어요.
  | 헤더 | 설명
  | :-----------: | :--------------------------------------------: |
  | `Cache-Control` | 메시지와 함께 캐시 지지자를 전달하기 위해 사용 |

### 요청 헤더

- 요청 메시지에서만 의미를 갖는 헤더예요.
- fetch될 리소스나 클라이언트 자체에 대한 자세한 정보를 포함해요.
- 요청에 나타나는 모든 헤더가 요청 헤더인 것은 아니에요 (ex. 엔터티 헤더인 `content-length`)

  |     헤더     |                                 설명                                  |
  | :----------: | :-------------------------------------------------------------------: |
  |    `Host`    |                        서버의 호스트명과 포트                         |
  | `User-Agent` |                    요청을 보낸 애플리케이션의 이름                    |
  |   `Origin`   | `POST`같은 요청을 보낼 때, 요청이 어느 주소에서 시작되었는지를 나타냄 |
  |  `Referer`   |       현재 페이지로 연결되는 링크가 있던 이전 웹 페이지의 주소        |

#### Accept 관련 헤더

- 자신의 선호와 능력을 알려줄 수 있는 헤더예요.

- 클라이언트가 무엇을 원하고, 무엇을 할 수 있는지, 무엇을 원하지 않는지 등을 통해 서버는 무엇을 보낼 것인가에 대해 더 똑똑한 결정을 내릴 수 있어요.

  |   헤더   |                           설명                            |
  | :------: | :-------------------------------------------------------: |
  | `Accept` | 클라이언트가 이해 가능한 컨텐츠 타입이 무엇인지를 알려줌. |

#### 조건부 요청 헤더

- 클라이언트는 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하게 하는 제약을 포함시킬 수 있어요.

  |        헤더         |                                         설명                                         |
  | :-----------------: | :----------------------------------------------------------------------------------: |
  | `If-Modified-Since` |             주어진 날짜 이후에 리소스가 변경되지 않았다면 요청을 제한함.             |
  |   `If-None-Match`   | 서버보고 ETag가 달라졌는지 검사해서 ETag가 다를 경우에만 컨텐츠를 새로 내려주라는 뜻 |

#### 요청 보안 헤더

- HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖췄어요.
- 요청하는 클라이언트가 어느 정도 리소스에 접근하기 전에 자신을 인증하게 함으로써 트랜잭션을 약간 더 안전하게 만들기 위해 사용하는 헤더예요.

  |      헤더       |                              설명                               |
  | :-------------: | :-------------------------------------------------------------: |
  | `Authorization` | 클라이언트가 서버에게 제공하는 인증 그 자체에 대한 정보를 담음. |
  |    `Cookie`     |        클라이언트가 서버에게 토큰(쿠키)을 전달할 떄 사용        |

#### 프락시 요청 헤더

- 프락시의 기능을 돕기 위한 헤더예요.

### 응답 헤더

- 위치 또는 서버 자체에 대한 정보(이름, 버전 등)와 같이 응답에 대한 부가 정보를 갖고, 클라이언트에게 제공해요.

- 응답에 나타나는 모든 헤더가 응답 헤더인 것은 아니에요. (ex. 엔터티 헤더인 `content-length`)

  |           헤더            |                                           설명                                           |
  | :-----------------------: | :--------------------------------------------------------------------------------------: |
  |           `Age`           |      캐시 응답 때 나타나는데, max-age 시간 내에서 얼마나 흘렀는지 초 단위로 알려줌.      |
  |   `Content-Disposition`   | 응답 본문을 브라우저가 어떻게 표시해야 할지 알려주는 헤더 주로 다운로드 관련해서 사용됨. |
  | `Content-Security-Policy` |        다른 외부 파일들을 불러오는 경우, 차단할 소스와 불러올 소스를 여기에 명시         |

#### 협상 헤더

- 서버가 협상 가능한 리소스에 대한 정보를 운반하는 헤더예요.

#### 응답 보안 헤더

- 기본적으로 HTTP 인증요구/응답 체계에서 응답 측에 해당하는 요청 보안 헤더예요.

  |        헤더        |                                      설명                                      |
  | :----------------: | :----------------------------------------------------------------------------: |
  |    `Set-Cookie`    | 서버가 클라이언트를 인증할 수 있도록 클라이언트 측에 토큰을 설정하기 위해 사용 |
  | `WWW-Authenticate` |                   서버에서 클라이언트로 보낸 인증요구의 목록                   |

### 엔터티 헤더

- 엔터티 바디에 대한 자세한 정보를 포함하는 헤더예요.

- 요청과 응답 양쪽 모두에 엔터티(본문)을 포함하기 때문에 양쪽 모두 엔터티 헤더가 나타날 수 있어요.

  |    헤더    |                       설명                        |
  | :--------: | :-----------------------------------------------: |
  |  `Allow`   | 엔터티에 대해 수행될 수 있는 요청 메서드들을 나열 |
  | `Location` |             페이지를 리다이렉트할 URL             |

#### 콘텐츠 헤더

- 엔터티의 콘텐츠에 대한 구체적인 정보 제공해요.

  |        헤더        |                 설명                  |
  | :----------------: | :-----------------------------------: |
  | ` Content-Length`  | 본문 길이나 크기를 바이트 단위로 표시 |
  |   `Content-Type`   |   컨텐츠 타입과 문자열 인코등 명시    |
  | `Content-Language` |             사용자의 언어             |
  | `Content-Encoding` |         컨텐츠가 압축된 방식          |

#### 엔터티 캐싱 헤더

- 엔터티 캐싱에 대한 정보 (리소스에 대해 캐시된 사본이 아직 유효한지에 대한 정보와 캐시된 리소스가 더 이상 유효하지 않게 되는 시점 추정을 위한 단서)를 제공해요.

  |   헤더    |                      설명                      |
  | :-------: | :--------------------------------------------: |
  |  `ETag`   | HTTP 컨텐츠가 바뀌었는지를 검사할 수 있는 태그 |
  | `Expires` |     응답 컨텐츠가 언제 만료되는지를 나타냄     |

### 확장 헤더 (\*\*)

- 애플리케이션 개발자들에 의해 만들어졌지만 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더예요.
  - 예를 들면, 구글에서 확장 응답 헤더로 사용되고 있는 `x-frame-OPTIONS`, `x-xss-protection`가 있어요.
  - 이 같은 커스텀 헤더는 'x-'를 붙여 사용했는데 이 관례는 2012년에 사라졌어요.
- HTTP 프로그램은 확장 헤더들에 대해 잘 모를지라도 전달해야 할 필요가 있어요.

## 본문(엔터티 본문)

- 선택적인 데이터 덩어리로, HTTP 메시지의 화물이에요.
- 그래서 이미지, 비디오, HTML 문서 등등 여러 종류의 디지털 데이터를 실어 나를 수 있어요.
- 하지만 모든 메시지가 본문을 갖는 것이 아니기 때문에 그냥 빈줄(CRLF)로 끝나기도 해요. 빈줄로 끝난다는 의미는 위의 메시지 문법 예시 이미지에서 확인 가능해요.
- 각 메서드 마다 본문이 존재할수도, 안 할수도 있어요. 아래 표를 참고해주세요.

  |  메서드   | 요청의 경우 | 응답의 경우 |
  | :-------: | :---------: | :---------: |
  |   `GET`   |      X      |      O      |
  |  `HEAD`   |      X      |      O      |
  |  `POST`   |      O      |      O      |
  |   `PUT`   |      O      |      X      |
  | `OPTIONS` |      X      |      O      |
  | `DELETE`  |      △      |      △      |
  |  `PATCH`  |      O      |      O      |
  |  `TRACE`  |      X      |      O      |
